% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/remlf90-class.R
\name{remlf90}
\alias{remlf90}
\title{Inference with REMLF90}
\usage{
remlf90(fixed, random = NULL, genetic = NULL, spatial = NULL,
  generic = NULL, data, var.ini = NULL, method = c("ai", "em"),
  breedR.bin = breedR.getOption("breedR.bin"), progsf90.options = NULL,
  weights = NULL, debug = FALSE)
}
\arguments{
\item{fixed}{an object of class \link{formula} (or one that can be coerced to
that class): a symbolic description of the fixed effects of the model to be
fitted. The details of model specification are given under 'Details'.}

\item{random}{if not \code{NULL}, an object of class \link{formula} with the 
unstructured random effects.}

\item{genetic}{if not \code{NULL}, a list with relevant parameters for an 
additive genetic effect; see 'Details'.}

\item{spatial}{if not \code{NULL}, a list with relevant parameters for a 
spatial random effect; see 'Details'.}

\item{generic}{if not \code{NULL}, a named list with an \code{incidence} 
matrix and either a \code{covariance} or a \code{precision} matrix; see 
'Details'.}

\item{data}{a data frame with variables and observations}

\item{var.ini}{if not \code{NULL}, a named list with one item for each random
component in the model. See 'Details'.}

\item{method}{either 'ai' or 'em' for Average-Information or 
Expectation-Maximization REML respectively}

\item{breedR.bin}{character. The local directory where the package binaries 
are stored, or any of 'remote' or 'submit' for remote computing. See 
'Details'.}

\item{progsf90.options}{character. Passed directly to OPTIONS field in 
PROGSF90. See available options for 
\href{http://nce.ads.uga.edu/wiki/doku.php?id=readme.reml#options}{REMLF90}
and for 
\href{http://nce.ads.uga.edu/wiki/doku.php?id=readme.aireml#options}{AIREMLF90}.
 Option \code{sol se} is passed always and cannot be removed. No checks are
performed, handle with care.}

\item{weights}{numeric. A vector of weights for the residual variance.}

\item{debug}{logical. If \code{TRUE}, the input files for blupf90 programs 
and their output are shown, but results are not parsed.}
}
\value{
An object of class 'remlf90' that can be further questioned by 
  \code{\link{fixef}}, \code{\link{ranef}}, \code{\link{fitted}}, etc.
}
\description{
Fits a Linear Mixed Model by Restricted Maximum Likelihood
}
\details{
If either \code{genetic} or \code{spatial} are not \code{NULL}, the 
  model residuals are assumed to have an additive genetic effects or a 
  spatially structured random effect, respectively. In those cases, 
  \code{genetic} and \code{spatial} must be lists with named relevant 
  parameters.
  
  The \code{generic} component implements random effects with custom 
  incidence and covariance (or precision) matrices. There can be any number 
  of them, stored in a named list with custom unique names that will be used 
  to identify and label the results. Each effect in the list must have an 
  \code{incidence} argument and either a \code{covariance} or a 
  \code{precision} matrix with conforming and suitable dimensions. 
  Optionally, an initial variance for the REML algorithm can be specified in 
  a third argument \code{var.ini}.
  
  \subsection{Genetic effect}{ The available models for the genetic effect 
  are \code{add_animal} and \code{competition}. \code{add_animal} stands for 
  an additive animal model with a given pedigree. \code{competition} includes
  the \emph{direct} additive genetic effect and also a \emph{competition} 
  additive genetic effect possibly correlated with the former.
  
  The minimum elements in the list of the \code{genetic} component are: 
  \itemize{\item \code{model} a string, either \code{add_animal} or 
  \code{competition} \item \code{pedigree} either an object of class 
  \code{pedigree} (see \code{\link{build_pedigree}}) or a \emph{data.frame} 
  with exactly three columns identifying the individual, his father and his 
  mother respectively \item \code{id} either a vector of codes or the name of
  the variable with the individual identifier in the \code{data}}
  
  Optional common components are:
  
  \itemize{ \item \code{var.ini} a positive initial value for the variance 
  component(s). For a \code{competition} model, the same initial value is 
  used for both effects, with a negative initial correlation between them of 
  half this value.}
  
  Finally, for model \code{competition} there are further mandatory and 
  optional elements:
  
  \itemize{ \item mandatory elements \itemize{ \item \code{coord} a matrix, 
  list or data.frame with two columns for the rows and columns of the 
  observations, respectively. This element is necessary even if duplicated in
  a \code{spatial} component. \item \code{competition_decay} a positive 
  number. The intensity of competition is weighted by the distance according 
  to \eqn{1/d^\alpha}. This element specifies the exponent \eqn{\alpha} to be
  used. Typically \eqn{1} or \eqn{2}. }
  
  \item optional elements \itemize{ \item \code{pec} Permanent Environmental 
  Competition effect. If present, this must be a named list with elements 
  \code{present} which is either \code{TRUE} or \code{FALSE} and (optionally) 
  \code{var.ini} specifying the initial variance for this effect. } }
  
  The Permanent Environmental Competition (\code{pec}) effect is actually 
  non-genetic in nature. However, it was included as an option to the 
  (genetic) competition effect as it is usually used in conjunction with it. 
  }
  
  
  \subsection{Spatial effects}{ The available models for the spatial effect 
  are \code{splines} and \code{AR1}. \code{splines} uses a  two-dimensional 
  tensor product of B-splines to represent the smooth spatially structured 
  effect (Cappa and Cantet, 2007). \code{AR1} uses a kronecker product of 
  autoregressive models for the rows and columns (Dutkowski et al., 2002).
  
  In both cases, the minimum necessary components in the list are \itemize{ 
  \item \code{model} a string, either \code{splines} or \code{AR} \item 
  \code{coord} a matrix, list or data.frame with two columns for the rows and
  columns respectively. }
  
  Optional common components are \itemize{ \item \code{var.ini} a positive 
  initial value for the variance component }
  
  Finally, optional model-dependent components are \itemize{ \item For model 
  \code{splines} \itemize{ \item \code{n.knots} a vector of two integers with
  the number of \emph{internal} knots for the rows and columns of the spline 
  design } \item For model \code{AR} \itemize{ \item \code{rho} a vector of 
  two numbers strictly between -1 and 1 with the autoregressive parameters 
  for the rows and columns respectively. Alternatively, a matrix or 
  data.frame with two columns where every row contain a combination of 
  autoregressive parameters to be tried. } }
  
  The \emph{internal} knots cover the region with observations at regular 
  intervals (in each dimension). For the splines design, three additional 
  knots are automatically added before the first internal knot, and other 
  tree after the last one, in each dimension. As a result, if \code{n.knots =
  c(n1, n2)}, then the final number of parameters of the splines model is 
  \eqn{(n1 + 2)(n2 + 2)}.
  
  If \code{n.knots} is omitted, a sensible number of knots for each dimension
  is computed based on the number of observations in the experiment. See the 
  internal function \code{\link{determine.n.knots}}. This is the default 
  function that computes the default number of knots, but you can provide an 
  alternative default function through \code{\link{breedR.setOption}}.
  
  Due to limitations of the REML backend, we can only fit models with 
  \emph{fixed} autoregressive parameters. \code{remlf90()} will fit as many 
  models as rows in \code{rho}, and return the results of the most likely. It
  will also return the list of log-likelihoods for each tried combination of 
  autoregressive parameters, in the component \code{rho} of the \code{reml} 
  object. This is useful for visualization, and further refinement of the 
  search for appropriate parameters.
  
  If any of the values in either column of \code{rho} is \code{NA}, then a 
  default set of values for the corresponding dimension will be set. See 
  \code{breedR.getOption('ar.eval')}, for the current defaults. You can set 
  your own defaults with \code{\link{breedR.setOption}}. Each will be 
  combined with every other value in the other column.
  
  Omitting the specification of \code{rho} is equivalent to \code{rho = c(NA,
  NA)}. }
  
  \subsection{Intercept}{ An intercept is automatically introduced in the 
  model provided the user doesn't explicitly prevents it by using \code{0} or
  \code{-1} in the \code{fixed} formula (as conventional in \code{R}), 
  \emph{and} there are no other categorical covariates in \code{fixed}. The 
  latter condition is actually a limitation of (ai)remlf90 backends, which 
  would in any case return an estimate for each level of the categorical 
  covariates while returning 0 for the intercept. It does not allow 
  alternative parameterizations. }
  
  
  \subsection{Initial variances}{ Initial variance components can also be 
  specified through an additional argument \code{var.ini}. You can either use
  default initial values for the variance components (see 
  \code{?breedR.options}) or specify custom values for \emph{each} and 
  \emph{all} variance components in the model. In this case, \code{var.ini} 
  must be a named list with one element for each term in \code{random} with 
  matching names, plus one last element named \code{residual} for the initial
  residual variance. Furthermore if there are \code{genetic} or 
  \code{spatial} effects, they must as well include a numeric element 
  \code{var.ini} with the initial variance component specification for the 
  corresponding effect. }
  
  
  \subsection{Inference method}{ AI-REML is usually faster than EM-REML, and 
  it provides more results. Namely, standard errors of the variance 
  components estimates, and covariances as well. On the other hand, is less 
  robust than EM-REML and it usually gives extreme results when used with the
  splines spatial model (as in \code{spatial = list(model ='splines', ...)}).
  
  Even when an effect accounts for no variance at all, EM-REML will always 
  estimate a positive variance which will be determined by the starting 
  value. If AI-REML does not converge but EM-REML does with the same dataset 
  and model, re-run EM-REML with a small starting value for the effect. If 
  the estimate does not change, it is likely that there is no variance. }
  
  \subsection{Remote computing}{ If \code{breedR.bin = 'remote'}, the REML 
  program will be run remotely and the results will be automatically 
  transferred back automatically. While if \code{breedR.bin = 'submit'} the 
  job will be submitted to the server, and the job-id and other relevant 
  information about the model will be returned instantly. The returned object
  can be used to retrieve the results or check the status of the job. Several
  jobs can be submitted in parallel. See \code{?remote} to learn how to 
  configure breedR for remote computing, and how to manage submitted jobs.}
}
\examples{
## Linear model
n <- 1e3
dat <- transform(data.frame(x = runif(n)),
                 y = 1 + 2*x + rnorm(n, sd = sqrt(3)))
res.lm <- remlf90(fixed = y ~ x, data = dat)
summary(res.lm)

## Linear Mixed model
f3 = factor(sample(letters[1:3], n, replace = TRUE))
dat <- transform(dat,
                 f3 = f3,
                 y = y + (-1:1)[f3])
res.lmm <- remlf90(fixed  = y ~ x,
                   random = ~ f3,
                   data   = dat)

## Generic model (used to manually fit the previous model)
inc.mat <- model.matrix(~ 0 + f3, dat)
cov.mat <- diag(3)
res.lmm2 <- remlf90(fixed  = y ~ x,
                    generic = list(f3 = list(inc.mat,
                                             cov.mat)),
                    data   = dat)
all.equal(res.lmm, res.lmm2, check.attributes = FALSE)  # TRUE
               
## Animal model
ped <- build_pedigree(c('self', 'dad', 'mum'),
                      data = as.data.frame(m1))
res.am <- remlf90(fixed   = phe_X ~ sex,
                  genetic = list(model    = 'add_animal',
                                 pedigree = ped,
                                 id       = 'self'),
                  data    = as.data.frame(m1))
                  
\dontrun{
## Same model with specification of initial variances
res.am <- remlf90(fixed   = phe_X ~ sex,
                  genetic = list(model    = 'add_animal',
                                 pedigree = ped,
                                 id       = 'self',
                                 var.ini  = 1),
                  data    = as.data.frame(m1),
                  var.ini = list(resid = 1))
 
## Animal-spatial models
gen.globulus <- list(model    = 'add_animal',
                     pedigree = globulus[, 1:3],
                     id       = 'self')
res.bm <- remlf90(fixed   = phe_X ~ gg,
                  genetic = gen.globulus,
                  spatial = list(model = 'blocks', 
                                 coord = globulus[, c('x','y')],
                                 id    = 'bl'),
                  data    = globulus)
                  
res.am <- remlf90(fixed   = phe_X ~ gg,
                  genetic = gen.globulus,
                  spatial = list(model = 'AR', 
                                 coord = globulus[, c('x','y')],
                                 rho   = c(.85, .8)),
                  data    = globulus)

res.sm <- remlf90(fixed   = phe_X ~ gg,
                  genetic = gen.globulus,
                  spatial = list(model = 'splines', 
                                 coord = globulus[, c('x','y')],
                                 n.knots = c(5, 5)),
                  data    = globulus,
                  method  = 'em')   # Necessary for splines models!!!


## Competition models

# This may take some minutes...
# and need to be fitted with 'em'
res.cm <- remlf90(fixed   = phe_X ~ 1,
                 genetic = list(model = 'competition',
                                pedigree = globulus[, 1:3],
                                id = 'self',
                                coord = globulus[, c('x','y')],
                                competition_decay = 1,
                                pec = list(present = TRUE)),
                 method = 'em',
                 data = globulus)
}

}
\references{
progsf90 wiki page: \url{http://nce.ads.uga.edu/wiki/doku.php}
  
  E. P. Cappa and R. J. C. Cantet (2007). Bayesian estimation of a surface to
  account for a spatial trend using penalized splines in an individual-tree 
  mixed model. \href{http://dx.doi.org/10.1139/x07-116}{\emph{Canadian 
  Journal of Forest Research} \strong{37}(12):2677-2688}.
  
  G. W. Dutkowski, J. Costa e Silva, A. R. Gilmour, G. A. López (2002). 
  Spatial analysis methods for forest genetic trials. 
  \href{http://dx.doi.org/10.1139/x02-111}{\emph{Canadian Journal of Forest 
  Research} \strong{32}(12):2201-2214}.
}
\seealso{
\code{\link[pedigreemm]{pedigree}}
}

